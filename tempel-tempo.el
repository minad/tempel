;;; tempel-tempo.el --- Tempo Compatibility layer    -*- lexical-binding: t; -*-

;; Copyright (C) 2026 Free Software Foundation, Inc.

;; Author: Elias Gabriel PÃ©rez <eg642616@gmail.com>
;; Keywords: abbrev, languages, tools, text

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:

;; This package provides ports of some tempo functions and variables.

;;; Code:

(require 'tempel)


;;; User Options

(defgroup tempel nil
  "Flexible template insertion."
  :prefix "tempo-"
  :group 'tools
  :group 'tempel)

;; NOTE: `tempel-tempo-insert-region' and `tempel-tempo-interactive'
;; must have effect only in `tempo-complete-tag' and
;; `tempo-expand-if-complete'.

;; counterpart of `tempo-interactive'
(defcustom tempel-tempo-interactive nil
  "Prompt user for strings in templates.
If this variable is non-nil, tempel prompts the user for text to insert
in the templates."
  :type 'boolean)

;; counterpart of `tempo-insert-region'
(defcustom tempel-tempo-insert-region nil
  "Automatically insert current region when there is a `r' in the template.
If this variable is nil, `r' elements will be treated just like `p'
elements, unless the template function is given a prefix (or a non-nil
argument).  If this variable is non-nil, the behavior is reversed."
  :type 'boolean)

;; counterpart of `tempo-show-completion-buffer'
(defcustom tempel-tempo-show-completion-buffer t
  "If non-nil, show a buffer with possible completions.
This only have effect in `tempel-tempo-complete-tag'."
  :type 'boolean)

;; counterpart of `tempo-leave-completion-buffer'
;; TODO: How to implement this, deprecate it instead?
(defcustom tempel-tempo-leave-completion-buffer nil
  "Whether the completion buffer should be closed.
If nil, a completion buffer generated by \\[tempel-complete-tag]
disappears at the next keypress; otherwise, it remains forever.

This only have effect in `tempel-tempo-complete-tag'."
  :type 'boolean)


;;; Variables

(defvar tempel-tempo-tags nil
  "An association list with tags and corresponding templates.")

(defvar-local tempel-tempo-dirty-collection
  "Indicates if the tag collection needs to be rebuilt.")

(make-obsolete-variable
 'tempel-tempo-dirty-collection
 "This variable is not used anymore." "31.1")

(defvar-local tempel-tempo-local-tags nil
  "A list of locally installed tag completion lists.
`tempel-tempo-tags' is always in the last position in this list.")


;;; Functions and Macros

;; Not from tempo.el
(defmacro tempel-tempo--progn (&rest body)
  "Used to provide tempo compatibility to some functions.
This acts like `progn', with BODY."
  `(cl-letf (((symbol-function #'tempel--region)
              (lambda ()
                (when (and (use-region-p)
                           tempel-tempo-insert-region)
                  (when (< (mark) (point)) (exchange-point-and-mark))
                  (cons (point-marker) (mark-marker)))))
             ((symbol-function #'tempel--placeholder)
              (lambda (st &optional prompt name noinsert only-prompt)
                (when tempel-tempo-interactive (setq only-prompt t))
                (setq prompt
                      (cond
                       ((and (stringp prompt) (or only-prompt noinsert))
                        (read-string prompt))
                       ((stringp prompt) (propertize prompt 'tempel--default t))
                       ;; TEMPEL EXTENSION: Evaluate prompt
                       (t (eval prompt (cdr st)))))
                (if noinsert
                    (progn (setf (alist-get name (cdr st)) prompt) nil)
                  (tempel--field st name prompt))
                (deactivate-mark))))
     ,@body))

(defalias 'tempel-tempo-user-elements-functions 'tempel-user-elements
  "Element handlers for user-defined elements.

This is an abnormal hook where the functions are called with one argument
(an element in a template) and they should return something to be sent to
`tempel--insert' if they recognize the argument, and nil otherwise.")

(defalias 'tempel-tempo-insert-string-functions 'tempel-insert-string-functions)

;; Not from tempo.el
(defun tempel-tempo--get-tag ()
  "Return which tag to use.
This return `tempel-tempo-local-tags' if it have any template, otherwise
return `tempel-tempo-tags' value."
  (append tempel-tempo-local-tags tempel-tempo-tags))

(defun tempel-tempo-define-template (name elements &optional tag documentation taglist)
  "Define a template.
This function creates a template variable `tempel-tempo-template-NAME'
and an interactive function `tempel-tempo-template-NAME' that inserts
the template at the point.  The created function is returned.

NAME is a string that contains the name of the template, ELEMENTS is a
list of elements in the template, TAG is the tag used for completion,
DOCUMENTATION is the documentation string for the insertion command
created, and TAGLIST (a symbol) is the tag list that TAG (if provided)
should be added to.  If TAGLIST is nil and TAG is non-nil, TAG is
added to `tempo-tags'.  If TAG already corresponds to a template in
the tag list, modify the list so that TAG now corresponds to the newly
defined template.

The elements in ELEMENTS can be of several types:

 - A string: It is sent to the hooks in
   `tempel-tempo-insert-string-functions', and the result is inserted.
 - The symbol `p': Inserts an unnamed placeholder field.
 - The symbol `r': Inserts the currently active region.  If no region is
   active, a placeholder field is inserted.  If `tempel-done-on-region'
   is non-nil, the template is finished when you jump to the field (see
   also `q').
 - (p PROMPT <NAME> <NOINSERT>): If `tempel-tempo-interactive' is
   non-nil, the user is prompted in the minibuffer with PROMPT for a
   string to be inserted.  If the optional parameter NAME is non-nil,
   the text is saved for later insertion with the `s' tag.  If there
   already is something saved under NAME that value is used instead and
   no prompting is made.  If NOINSERT is provided and non-nil, nothing
   is inserted, but text is still saved when a NAME is provided.  For
   clarity, the symbol `noinsert' should be used as argument.
 - (P PROMPT <NAME> <NOINSERT>): Works just like the previous tag, but
   forces `tempel-tempo-interactive' to be true.
 - (r PROMPT <NAME> <NOINSERT>): Insert region or act like (p ...).
 - (s NAME): Inserts text previously read with the (p ..) construct.
   Finds the insertion saved under NAME and inserts it.  Acts like `p'
   if `tempel-tempo-interactive' is nil.
 - `&': If there is only whitespace between the line start and point,
   nothing happens.  Otherwise a newline is inserted.
 - `%': If there is only whitespace between point and end of line,
   nothing happens.  Otherwise a newline is inserted.
 - `n': Inserts a newline.
 - `>': The line is indented using `indent-according-to-mode'.  Note
   that you often should place this item after the text you want on
   the line.
 - `r>': Like `r', but it also indents the region.
 - (r> PROMPT <NAME> <NOINSERT>): Like (r ...), but is also indents
   the region.
 - `n>': Inserts a newline and indents line.
 - `o': Like `%' but leaves the point before the newline.
 - nil: It is ignored.
 - Anything else: Each function in `tempel-tempo-user-element-functions'
   is called with it as argument until one of them returns non-nil, and the
   result is inserted.  If all of them return nil, it is evaluated and
   the result is treated as an element to be inserted.  One additional
   tag is useful for these cases.  If an expression returns a list (l
   foo bar), the elements after `l' will be inserted according to the
   usual rules.  This makes it possible to return several elements
   from one expression."
  (let ((tag-name (intern (concat "tempel-tempo-template-" name)))
        (taglist (or taglist 'tempel-tempo-tags)))
    (set tag-name elements)
    (fset tag-name (lambda (&optional arg only-return)
		     (:documentation
		      (or documentation (concat "Insert a " name ".")))
		     (interactive "*P")
                     (unless only-return
                       (tempel--insert
                        elements
                        (and (or arg tempel-tempo-insert-region)
                             (tempel--region))))
                     elements))
    (when tag (tempel-tempo-add-tag tag elements taglist))
    tag-name))

(defun tempel-tempo-use-tag-list (tag-list)
  "Install TAG-LIST to be used for template completion in the current buffer.
TAG-LIST is a symbol whose variable value is a tag list created with
`tempo-add-tag'."
  (setq-local tempel-tempo-local-tags (symbol-value tag-list)))

;; NOTE: It seems this function is internal use only in tempo.el
;; Currently this is only used in tests.
(defun tempel-tempo-insert-template (template on-region)
  "Insert a template.
TEMPLATE is the template to be inserted.  If ON-REGION is non-nil the
`r' elements are replaced with the current region.  In Transient Mark
mode, ON-REGION is ignored and assumed true if the region is active."
  (let ((tempel-tempo-insert-region
         (or on-region tempel-tempo-insert-region)))
    (tempel-tempo--progn
     (when (functionp template)
       (setq template (funcall template nil :only-return)))
     (tempel--insert template (tempel--region)))))


;;; Commands

;;;###autoload
(defalias 'tempel-tempo-forward-mark 'tempel-next
  "Jump to the next mark.")

;;;###autoload
(defalias 'tempel-tempo-backward-mark 'tempel-previous
  "Jump to the previous mark.")

;;;###autoload
(defun tempel-tempo-expand-if-complete ()
  "Expand the tag before point if it is complete.
Returns non-nil if an expansion was made and nil otherwise.

This could as an example be used in a command that is bound to the
space bar, and looks something like this:

\(defun tempel-space ()
  (interactive \"*\")
  (or (tempel-tempo-expand-if-complete)
      (insert \" \")))"
  (interactive)
  (tempel-tempo--progn
   (tempel--save)
   ;; This is extracted from `tempel-expand', we cannot define this as
   ;; alias because `tempel-expand' disables the region inserting.
   (if-let* ((templates (tempel--templates))
             (bounds (bounds-of-thing-at-point 'symbol))
             (name (buffer-substring-no-properties
                    (car bounds) (cdr bounds)))
             (sym (intern-soft name))
             (template (assq sym templates)))
       (tempel--exit templates (tempel--region) name 'finished)
     (user-error "tempel-expand: No matching templates"))))

;;;###autoload
(defun tempel-tempo-add-tag (tag template &optional tag-list)
  "Add a template tag.
Add the TAG, that should complete to TEMPLATE to the list in TAG-LIST,
or to `tempel-tempo-tags' if TAG-LIST is nil.  If TAG was already
in the list, replace its template with TEMPLATE."
  (interactive "sTag: \nCTemplate: ")
  (setq tag (intern tag))
  (unless tag-list (setq tag-list 'tempel-tempo-tags))

  (when (functionp template)
    (setq template (funcall template nil :only-return)))

  (let ((place (assoc tag (symbol-value tag-list))))
    (if place
        ;; Tag is already in the list, assign a new template to it.
        (setcdr place template)
      ;; Tag is not present in the list, add as a new template
      (add-to-list tag-list `(,tag ,@template)))))

;;;###autoload
(defun tempel-tempo-complete-tag (&optional _silent)
  "Look for a tag and expand it.
If a single match is found, the corresponding template is expanded in
place of the matching string.

If a partial completion is found and `tempel-tempo-show-completion-buffer' is
non-nil, a buffer containing possible completions is displayed."
  (interactive "*")
  (tempel-tempo--progn
   (tempel--save)
   (if tempel-tempo-show-completion-buffer ;; TODO: (?)
       ;; This let is for enable the region inserting
       (let ((this-command #'tempel-complete))
         (tempel-complete :interactive))
     (tempel-tempo-expand-if-complete))))



(add-hook 'tempel-template-sources #'tempel-tempo--get-tag)

(provide 'tempel-tempo)
;;; tempel-tempo.el ends here
